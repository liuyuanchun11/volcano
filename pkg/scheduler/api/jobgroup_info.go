/*
Copyright 2024 The Volcano Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/klog/v2"

	vcbatch "volcano.sh/apis/pkg/apis/batch/v1alpha1"
)

type JobGroupID types.UID
type ReplicatedJobName string

type JobGroupInfo struct {
	UID                    JobGroupID
	Name                   string
	Namespace              string
	MinAvailable           int32
	Replicas               int32
	Owner                  JobGroupOwner
	Jobs                   map[ReplicatedJobName]map[JobID]struct{}
	CreationTimestamp      metav1.Time
	ScheduleStartTimestamp metav1.Time
}

// JobGroupOwner owner type and pointer of the JobGroupInfo
type JobGroupOwner struct {
	Type     string
	HyperJob *vcbatch.HyperJob
}

// JobGroup generated by HyperJob, its owner is HyperJob
// +------------+   Owner  +------------+
// |  HyperJob  |  <------ |  JobGroup  |
// +------------+          +------------+
//
//							/     |     \
//	             	+-------+  +-------+  +-------+
//	             	|  Job  |  |  Job  |  |  Job  |
//	             	+-------+  +-------+  +-------+
//
// JobGroup generated by job, does not have an owner
//
//	+- - - - - - +
//	|  JobGroup  |
//	+- - - - - - +
//	       |
//	   +-------+
//	   |  Job  |
//	   +-------+
const (
	OwnerTypeHyperJob = "hyperJob"
	OwnerTypeNone     = "none"
)

func GetJobGroupID(namespace, name, UID string) JobGroupID {
	if len(UID) == 0 {
		return JobGroupID(fmt.Sprintf("%s/%s", namespace, name))
	} else {
		return JobGroupID(fmt.Sprintf("%s/%s-%s", namespace, name, UID))
	}
}

func NewJobGroupInfo(uid JobGroupID) *JobGroupInfo {
	jobGroup := &JobGroupInfo{
		UID:          uid,
		MinAvailable: 0,
		Replicas:     0,
		Jobs:         make(map[ReplicatedJobName]map[JobID]struct{}),
		Owner: JobGroupOwner{
			Type: "",
		},
	}

	return jobGroup
}

func (jgi *JobGroupInfo) SetJobGroup(jobGroup *JobGroupInfo) {
	jgi.Namespace = jobGroup.Namespace
	jgi.Name = jobGroup.Name
	jgi.Replicas = jobGroup.Replicas
	jgi.MinAvailable = jobGroup.MinAvailable
	if jgi.MinAvailable <= 0 {
		jgi.MinAvailable = jgi.Replicas
	}
	jgi.Owner = jobGroup.Owner
	jgi.CreationTimestamp = jobGroup.CreationTimestamp

	klog.V(3).Infof("Set jobGroup %s, total job replicas %d, minAvailable %d, owner type %s",
		jgi.UID, jgi.Replicas, jgi.MinAvailable, jgi.Owner.Type)
}

func (jgi *JobGroupInfo) UnsetOwner() {
	jgi.Owner.Type = ""
	jgi.Owner.HyperJob = nil
	klog.V(3).Infof("Unset jobGroup owner %s", jgi.UID)
}

func (jgi *JobGroupInfo) Clone() *JobGroupInfo {
	jobGroupTmp := &JobGroupInfo{
		UID:          jgi.UID,
		Name:         jgi.Name,
		Namespace:    jgi.Namespace,
		MinAvailable: jgi.MinAvailable,
		Replicas:     jgi.Replicas,
		Owner: JobGroupOwner{
			Type:     jgi.Owner.Type,
			HyperJob: jgi.Owner.HyperJob,
		},
		Jobs: make(map[ReplicatedJobName]map[JobID]struct{}),
	}

	jgi.CreationTimestamp.DeepCopyInto(&jobGroupTmp.CreationTimestamp)
	for rjName, jobs := range jgi.Jobs {
		jobGroupTmp.Jobs[rjName] = make(map[JobID]struct{})
		for jobId := range jobs {
			jobGroupTmp.Jobs[rjName][jobId] = struct{}{}
		}
	}
	return jobGroupTmp
}

func getReplicatedJobName(jobInfo *JobInfo) (ReplicatedJobName, error) {
	if jobInfo.PodGroup == nil {
		return "", fmt.Errorf("get replicatedJob name failed, job %s has no podgroup", jobInfo.UID)
	}
	rjName, exist := jobInfo.PodGroup.Annotations[vcbatch.HyperJobReplicatedJobNameKey]
	if !exist {
		// If the job is not created by hyerpjob, the job name is returned
		return ReplicatedJobName(jobInfo.Name), nil
	}
	return ReplicatedJobName(rjName), nil
}

func (jgi *JobGroupInfo) AddJobInfo(jobInfo *JobInfo) error {
	rjName, err := getReplicatedJobName(jobInfo)
	if err != nil {
		return err
	}

	if _, ok := jgi.Jobs[rjName]; !ok {
		jgi.Jobs[rjName] = make(map[JobID]struct{})
	}
	jgi.Jobs[rjName][jobInfo.UID] = struct{}{}
	klog.V(3).Infof("Add jobInfo %s(rj name %s) to jobGroupInfo %s", jobInfo.UID, rjName, jgi.UID)

	return nil
}

func (jgi *JobGroupInfo) DelJobInfo(jobInfo *JobInfo) error {
	rjName, err := getReplicatedJobName(jobInfo)
	if err != nil {
		return err
	}

	if _, ok := jgi.Jobs[rjName]; !ok {
		return nil
	}
	if _, ok := jgi.Jobs[rjName][jobInfo.UID]; !ok {
		return nil
	}
	delete(jgi.Jobs[rjName], jobInfo.UID)

	if len(jgi.Jobs[rjName]) == 0 {
		delete(jgi.Jobs, rjName)
	}
	klog.V(3).Infof("Delete jobInfo %s(rj name %s) from jobGroupInfo %s", jobInfo.UID, rjName, jgi.UID)
	return nil
}

func (jgi *JobGroupInfo) IsOwnerValid() bool {
	switch jgi.Owner.Type {
	case OwnerTypeHyperJob:
		return jgi.Owner.HyperJob != nil
	case OwnerTypeNone:
		return true
	}
	return false
}

func (jgi *JobGroupInfo) GetJobNum() int {
	var jobNum int
	for _, jobs := range jgi.Jobs {
		jobNum += len(jobs)
	}
	return jobNum
}

func (jgi *JobGroupInfo) IsTerminated() bool {
	if jgi.GetJobNum() == 0 && !jgi.IsOwnerValid() {
		return true
	}

	return false
}

func (jgi *JobGroupInfo) IsValid() bool {
	if !jgi.IsOwnerValid() {
		return false
	}
	switch jgi.Owner.Type {
	case OwnerTypeHyperJob:
		if jgi.GetJobNum() != 0 {
			return true
		}
	case OwnerTypeNone:
		if jgi.Replicas == 1 && jgi.GetJobNum() == 1 {
			return true
		}
	}

	return false
}

func (jgi *JobGroupInfo) GetAnyOneJobId() (JobID, error) {
	for _, jobs := range jgi.Jobs {
		for jobId := range jobs {
			return jobId, nil
		}
	}
	return "", fmt.Errorf("failed to get any one job")
}
